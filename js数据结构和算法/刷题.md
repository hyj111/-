# 数组

## 删除排序数组中的重复项

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 

示例 1:

```js
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```


示例 2:

```js
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

题目分析：这是一个排序数组，从小到大排序，不允许创建新数组，只能在原数组操作

**解答：**

```js
    var removeDuplicates = function (nums) {
        let i = 0;
        for(let j = 1;j<nums.length;j++){
            if(nums[i] != nums[j]){
                i++
                nums[i] = nums[j]              
            }      
        }
        nums.length = i+1
        return i+1
    };
```

**采用双指针法**：先设置一个指针`i=0`；数组从`j=1`开始，如果第`i`项目和第`j`项相等那就`j++`,i不变，如果相等则第`i++`项，等于`j`,当遍历完所有元素之后，再把length长度设为i+1，则达到去重效果。

## 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```


示例 2:

```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**解答1：**

```js
    var rotate = function (nums, k) {
        for (let i = 0; i < k; i++) {
            nums.splice(0,0,nums.pop())
            // nums.unshift(nums.pop())
            console.log(nums);
        }      
        return nums
    };
```

根据k来判断执行多少次for循环，每执行依次都先向数组末尾的数删除，然后加到数组前面。

## 存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 

示例 1:

```js
输入: [1,2,3,1]
输出: true
```


示例 2:

```js
输入: [1,2,3,4]
输出: false
```

**解答:**

```js
  var containsDuplicate = function(nums) {
        const s = new Set(nums)
        return s.size === nums.length?false:true
    };
```

使用ES6新增的数据结构set，它类似于数组，但是成员的值都是唯一的，没有重复的值。他可以接收数组且自动去重，所以用他来接收数组，再判断他的长度（`size`）和原数组的长度（`length`）比较，若相等则证明数组中没有重复值，返回`false`，反之返回`true`

## 只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

```
输入: [2,2,1]
输出: 1
```


示例 2:

```
输入: [4,1,2,1,2]
输出: 4
```

解答：

```js
  var singleNumber = function(nums) {
        let temp = 0
      for(let item of nums){
        temp = temp ^item
      }
      return temp
    };
```

使用异或来计算，因为

* 所有数和0异或都等于本身 a⊕0 = a
* 两个相等的数异或等于0 a⊕a = 0
* 异或满足交换律 a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b

## 两个数组的交集 II

给定两个数组，编写一个函数来计算它们的交集。

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```


示例 2:

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- **输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。（重点注意）**
- 我们可以不考虑输出结果的顺序。

**解答1：**

```js
var intersect = function(nums1, nums2) {    
    nums1.sort((a,b)=>{return a-b})
    nums2.sort((a,b)=>{return a-b})
    let p1 =0
    let p2 =0
    let newArr = []
    while(p1<nums1.length&&p2<nums2.length){
        if(nums1[p1] == nums2[p2]){// 遇到相同的，推入res数组，两个指针同时移动考察下一个
            newArr.push(nums1[p1]);
            p1++;
            p2++;
        }else if(nums1[p1] < nums2[p2]){ //遇到不同，小的那个数指针加1。
            p1++
        }else{
            p2++
        }
    }
    return newArr

};
```

采用双指针法，先把数组按从小到大顺序排序，这样就能让相同的元素相邻，分别给两个数组都设置指针，设置循环两个数组都没有越界时就接着循环，遇到相同的，推入newArr数组，两个指针同时移动考察下一个，遇到不同，小的那个数指针加1。

## 加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

```
输入: [4,9,9]
输出: [5,0,0]
解释: 输入数组表示数字 500。
```


示例 2:

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

示例 3：

```
输入: [9，9，9]
输出: [1,0,0,0]
解释: 输入数组表示数字 1000。
```

**三种情况分析：**

1.末位无进位，则末位加一即可，因为末位无进位，前面也不可能产生进位，比如 45 => 46
2.末位有进位，在中间位置进位停止，则需要找到进位的典型标志，即为当前位 %10后为 0，则前一位加 1，直到不为 0 为止，比如 499 => 500
3.末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第 2 种情况遍历结束的基础上，进行单独处理，比如 999 => 1000

**解答：**

```js
var plusOne = function(digits) {
     for(let i=digits.length-1;i>=0;i--){
         digits[i]++; //最后一位数加1
         digits[i] = digits[i] % 10 // 确保最后一个元素是个位数
         if(digits[i]!=0){
             return digits
         }  
    }
    digits.unshift(1)
    return digits
};
```

对数组从后往前遍历，让最后一位数加1，再对10**求余**这样能保证该数字为个位数，进行判断该数字结果，若不为0，则返回数组结束循环。如果等于0则需要进位，那么它的前一位也要执行一遍这个流程直到不等于0，如果执行完了所有位数都等于0，则需要给数组头添加一个1。

## 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**解答1：**

```js
    var moveZeroes = function (nums) {
        let j =0 // j是用来做下标的
        let i = 0 //定义两指针，i是用来循环用的
        while(i<nums.length){ // 遍历数组
            if(nums[j] == 0){ // 如果遍历到的数组等于0
                nums.splice(i,1) //则删除该位置数组，删除该位置数组后，元素原本的下一位就顶上来了所以j不用加1
                nums.push(0) //在末尾添加0，
            }else{
                j++ // 数组等于0则需要对 j++往后寻找
            }
            i++;
        }               
    };
```

## 两数之和

定义两个指针是为了避免错过某些元素，因为当删除元素时，删除元素的前一位会掉下来，所以下标`j`不需要加1

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

**解答1：**暴力法

```js
  for(let i =0 ;i<nums.length;i++){
        let temp = target - nums[i]  
        if(nums.indexOf(temp,i+1)!=-1) { //indexOf第二个参数选择i+1，为了避免选到重复的数字
            return [i,nums.indexOf(temp,i+1)]
        }
    }
```

首先知道一个数组常用方法`数组.indexOf('要检测的数字'，从哪开始检测)`返回的是一个下标，如果每找到就返回-1。遍历每个元素并查找是否存在一个值与 target - x 相等的目标元素。

for...in...一个坑

```js
for(let i in arr) {
	console.log(i) //这是一个字符串
}
```

**解答2：**

```js
var twoSum = function(nums, target) {
    let obj = {} //将所有出现过的数字索引保存到对象上，key是值，value是下标
    for(let i =0;i<nums.length;i++){
        let curNum = nums[i]
        let temp  = target-curNum;
        //判断对象中是否有temp的索引值
        if(obj[temp] === undefined) {
            obj[curNum] = i //如果没有，就将数据存到对象中
        }else{
            //如果找到了就返回
            return [obj[temp],i]
        }
    }
};
```

## 买卖股票的最佳时机 II

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 

示例 1:

```js
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```


示例 2:

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```


示例 3:

```
输入: [7,6,4,3,1]
输出: 0
```

解答1：

```js
var maxProfit = function(prices) {
    let total = 0
    for(let i =0;i<prices.length;i++) {
        if(prices[i]<prices[i+1]){ //只要第二天价格比第一个高就买
            total=total+prices[i+1] - prices[i]
        }
    }
    return total
};
```



# 链表

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

2+5 = 7 第一位是7

4+6 =10 所以进位取0 

3+4 = 7 因为上一位有进位所以取8

解答：

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let node = new ListNode('head') //创建一个头节点
    let lianbiao = node //创建一个链表
    let temp = 0 //用来标记是否需要进位
    while(l1||l2) { //只有当这两个链表都为空才停止循环
        let sum = (l1?l1.val:0) + (l2?l2.val:0)+temp // 相加  
        node.next = new ListNode(sum%10) //对10求余保证是个位数
        if(sum>=10){temp = 1}else{temp = 0} //判断是否需要进位
        node = node.next //前往下一个节点
        if(l1!=undefined) l1 = l1.next //前往下一个节点
        if(l2!=undefined) l2 = l2.next //前往下一个节点
    }
    if(temp == 1){node.next = new ListNode(1)} //循环最后一个还有进位的话，则添加一个节点让其val = 1
    return lianbiao.next //返回链表.next ,为什么不直接返回因为链表头是字符串head
};
```

